# This is an example script of creating input file for conregistration.py.
# The input file is a text file and contains comma-separated values.
# Each row has five fields -- index, longitude, latitude, time, and plate id.

# The script contains hardcoded file names.
# You should only use this script as an example and modify the example to prepare input data suitable to your research.

import geopandas as gpd
import numpy as np
from numpy import ones, vstack
from numpy.linalg import lstsq
import os, sys
# import pandas as pd
# from parameters import parameters
import shapefile
# from shapely import geometry
from shapely.geometry import LineString, Point, shape
import Utils

# the age is a floating-point number. map the floating-point number to the nereast integer time in the range
def get_time_from_age(ages, start, end, step):
    ret = []
    times = range(start, end+1, step)
    
    for age in ages:
        age = float(age)
        if age <= start:
            ret.append(start)
        elif age >= end:
            ret.append(end)
        else:
            idx = int((age - start)//step)
            mod = (age - start)%step
            if not (mod < step/2.):
                idx = idx+1 
            ret.append(times[idx])
            
    return ret

def process_real_deposits(deposit_path, start_time, end_time, time_step): # path to the shapefile of mineral occurrences
    if not os.path.isfile(deposit_path):
        sys.exit('File not found!')
    reader = shapefile.Reader(deposit_path)
    recs = reader.records()
    min_occ_num = len(recs)
    # longitude
    lons = np.array(recs)[:, 3]
    # latitude
    lats = np.array(recs)[:, 4]
    # time
    times = get_time_from_age(np.array(recs)[:, 14], start_time, end_time, time_step) # get integer ages
    # plate id
    plate_ids = Utils.get_plate_id(lons, lats)
    # index, lon, lat, time, plate id
    data = []
    
    for i in range(min_occ_num):
        data.append([i, lons[i], lats[i], times[i], plate_ids[i]])
    data = np.array(data)
    
    return data

# def generate_random_deposits(data, start_time, end_time):
#     random_data = []
#     random_ages = np.random.randint(start_time+1, end_time, size=len(data)) # generate random ages for mineral occurrences
#     for i in range(len(data)):
#         random_data.append([i, data[i][1], data[i][2], random_ages[i], data[i][4]])
#     return random_data

# # genrate buffer zones surrounding polylines (segment by segment)_v1.0_ignore the points close to the margins
# def generate_buffer_zones(subduction_geoms, radius): # subduction_geoms generated by Utils.get_subduction_geometries()
#     num_geoms = len(subduction_geoms)
#     buffer_zones_list = []
    
#     for i in range(num_geoms):
#         xy = subduction_geoms[i][0].to_lat_lon_array()
#         num_xy = xy.shape[0]
#         buffer_zones = []
#         for j in range(num_xy):
#             if j < num_xy-1:
#                 if xy[j, 1] * xy[j+1, 1] > 0 and\
#                     xy[j, 1] < 180-2*radius and\
#                         xy[j, 1] > -180+2*radius and\
#                             xy[j, 0] < 90-2*radius and\
#                                 xy[j, 0] > -90+2*radius:
#                     buffer_zone = gpd.GeoSeries(LineString([(xy[j, 1], xy[j, 0]), (xy[j+1, 1], xy[j+1, 0])])).buffer(radius, cap_style=2)
#                     buffer_zones.append(buffer_zone)
#                 else:
#                     xy_ = xy[j+1:]
#                     for k in range(xy_.shape[0]):
#                         if k < xy_.shape[0]-1 and\
#                             xy_[k, 1] < 180-2*radius and\
#                                 xy_[k, 1] > -180+2*radius and\
#                                     xy_[k, 0] < 90-2*radius and\
#                                         xy_[k, 0] > -90+2*radius:
#                             buffer_zone = gpd.GeoSeries(LineString([(xy_[k, 1], xy_[k, 0]), (xy_[k+1, 1], xy_[k+1, 0])])).buffer(radius, cap_style=2)
#                             buffer_zones.append(buffer_zone)
#                     break
#         if len(buffer_zones) > 0:
#             buffer_zones_df = gpd.GeoDataFrame(gpd.GeoSeries(buffer_zones[0]))
#             for m in range(1, len(buffer_zones)):
#                 buffer_zones_df.loc[m] = gpd.GeoSeries(buffer_zones[m])
#             buffer_zones_df = buffer_zones_df.rename(columns={0: 'geometry'}).set_geometry('geometry')
#             buffer_zone_dissolved = buffer_zones_df.dissolve()
#             buffer_zone_dissolved_ch = buffer_zone_dissolved.convex_hull
#             buffer_zones_list.append(buffer_zone_dissolved_ch)
    
#     buffer_zones_list_df = gpd.GeoDataFrame(gpd.GeoSeries(buffer_zones_list[0]))
#     for n in range(1, len(buffer_zones_list)):
#         buffer_zones_list_df.loc[n] = gpd.GeoSeries(buffer_zones_list[n])
#     buffer_zones_list_df = buffer_zones_list_df.rename(columns={0: 'geometry'}).set_geometry('geometry')
#     buffer_zones_list_dissolved = buffer_zones_list_df.dissolve()

#     return buffer_zones_list_dissolved

# # genrate buffer zones surrounding polylines (segment by segment)_v2.0_add 360 to negative x values
# def generate_buffer_zones(subduction_geoms, radius): # subduction_geoms generated by Utils.get_subduction_geometries()
#     num_geoms = len(subduction_geoms)
#     buffer_zones_list = []
    
#     for i in range(num_geoms):
#         xy = subduction_geoms[i][0].to_lat_lon_array()
#         num_xy = xy.shape[0]
#         for j in range(num_xy):
#             if j < num_xy-1 and xy[j, 1] * xy[j+1, 1] < 0:
#                 for k in range(num_xy):
#                     if xy[k, 1] < 0:
#                         xy[k, 1] = 360 + xy[k, 1]

#         buffer_zones = []
#         for m in range(num_xy):
#             if m < num_xy-1:
#                 buffer_zone = gpd.GeoSeries(LineString([(xy[m, 1], xy[m, 0]), (xy[m+1, 1], xy[m+1, 0])])).buffer(radius, cap_style=2)
#                 buffer_zones.append(buffer_zone)
#         buffer_zones_df = gpd.GeoDataFrame(gpd.GeoSeries(buffer_zones[0]))
#         for n in range(1, len(buffer_zones)):
#             buffer_zones_df.loc[n] = gpd.GeoSeries(buffer_zones[n])
#         buffer_zones_df = buffer_zones_df.rename(columns={0: 'geometry'}).set_geometry('geometry')
#         buffer_zone_dissolved = buffer_zones_df.dissolve()
#         buffer_zone_dissolved_ch = buffer_zone_dissolved.convex_hull
#         buffer_zones_list.append(buffer_zone_dissolved_ch)
    
#     buffer_zones_list_df = gpd.GeoDataFrame(gpd.GeoSeries(buffer_zones_list[0]))
#     for p in range(1, len(buffer_zones_list)):
#         buffer_zones_list_df.loc[p] = gpd.GeoSeries(buffer_zones_list[p])
#     buffer_zones_list_df = buffer_zones_list_df.rename(columns={0: 'geometry'}).set_geometry('geometry')
#     buffer_zones_list_dissolved = buffer_zones_list_df.dissolve()

#     return buffer_zones_list_df, buffer_zones_list_dissolved

# # genrate buffer zones surrounding polylines (segment by segment)_v3.0_split the set of points based on the sign of longitude
# def generate_buffer_zones(subduction_geoms, radius): # subduction_geoms generated by Utils.get_subduction_geometries()
#     lines_list = []
#     buffer_zones_list = []
#     buffer_zones_df_list = []

#     # split the line where it passes over anti-meridian
#     for geom in subduction_geoms:
#         index_list = []
#         xy = geom[0].to_lat_lon_array()
#         num_xy = xy.shape[0]
#         for i in range(num_xy):
#             if i < num_xy-1 and xy[i, 1] * xy[i+1, 1] < 0 and 180 - abs(xy[i, 1]) < abs(xy[i, 1]):
#                 index_list.append(i+1)
#         lines_list.append(np.split(xy, index_list))

#     for line in lines_list:
#         for segment in line:
#             if segment.shape[0] > 1:
#                 buffer_zones = []
#                 for j in range(segment.shape[0]-1):
#                     buffer_zone = gpd.GeoSeries(LineString([(segment[j, 1], segment[j, 0]), (segment[j+1, 1], segment[j+1, 0])])).buffer(radius, cap_style=2)
#                     buffer_zones.append(buffer_zone)
                
#                 # convert the list of geoseries objects to a geodataframe
#                 buffer_zones_df = gpd.GeoDataFrame(gpd.GeoSeries(buffer_zones[0]))
#                 for k in range(1, len(buffer_zones)):
#                     buffer_zones_df.loc[k] = gpd.GeoSeries(buffer_zones[k])
#                 buffer_zones_df = buffer_zones_df.rename(columns={0: 'geometry'}).set_geometry('geometry')
                
#                 buffer_zone_dis_ch = buffer_zones_df.iloc[0:2].dissolve().convex_hull
#                 for m in range(2, buffer_zones_df.shape[0]):
#                     buffer_zones_df_tmp = gpd.GeoDataFrame(buffer_zone_dis_ch)
#                     buffer_zones_df_tmp.loc[1] = buffer_zones_df.loc[m][0]
#                     buffer_zones_df_tmp = buffer_zones_df_tmp.rename(columns={0: 'geometry'}).set_geometry('geometry')
#                     buffer_zone_dis_ch = buffer_zones_df_tmp.dissolve().convex_hull
#                 buffer_zones_list.append(buffer_zone_dis_ch)
#                 buffer_zones_df_list.append(buffer_zones_df)
    
#     buffer_zones_list_df = gpd.GeoDataFrame(gpd.GeoSeries(buffer_zones_list[0]))
#     for m in range(1, len(buffer_zones_list)):
#         buffer_zones_list_df.loc[m] = gpd.GeoSeries(buffer_zones_list[m])
#     buffer_zones_list_df = buffer_zones_list_df.rename(columns={0: 'geometry'}).set_geometry('geometry')
#     buffer_zones_list_dis = buffer_zones_list_df.dissolve()

#     return buffer_zones_df_list, buffer_zones_list_dis

# # genrate buffer zones surrounding polylines (segment by segment)_v4.0_similar to the previous version but modifies the coordinates and generates buffer zones segment by segment
# def generate_buffer_zones(subduction_geoms, radius): # subduction_geoms generated by Utils.get_subduction_geometries()
#     lines_list = []
#     buffer_zones_list = []
#     buffer_zones_df_list = []

#     # add an appropriate vertex to the lines on anti-meridian
#     for geom in subduction_geoms:
#         index_list = []
#         vertex_list = []
#         xy = geom[0].to_lat_lon_array()
#         num_xy = xy.shape[0]
#         for i in range(num_xy-1):
#             if xy[i, 1] * xy[i+1, 1] < 0 and 180 - abs(xy[i, 1]) < abs(xy[i, 1]):
#                 index_list.append(i+1)
#                 m = (xy[i+1, 0] - xy[i, 0]) / (xy[i+1, 1] - xy[i, 1])
#                 b = xy[i, 0] - (m * xy[i, 1])
#                 pos_vertex = [m*180+b, 180]
#                 neg_vertex = [m*-180+b, -180]
#                 if xy[i, 1] > 0:
#                     vertex_list.append([pos_vertex, neg_vertex])
#                 else:
#                     vertex_list.append([neg_vertex, pos_vertex])

#         if len(index_list) > 0:
#             xy = np.insert(xy, index_list, np.array(vertex_list[0]), 0)

#         # split the line where it passes over anti-meridian
#         index_list = []
#         num_xy = xy.shape[0]
#         for i in range(num_xy-1):
#             if xy[i, 1] * xy[i+1, 1] < 0 and 180 - abs(xy[i, 1]) < abs(xy[i, 1]):
#                 index_list.append(i+1)
#         lines_list.append(np.split(xy, index_list))

#     for line in lines_list:
#         for segment in line:
#             buffer_zones = []
#             for j in range(segment.shape[0]-1):
#                 buffer_zone = gpd.GeoSeries(LineString([(segment[j, 1], segment[j, 0]), (segment[j+1, 1], segment[j+1, 0])])).buffer(radius, cap_style=2)
#                 buffer_zones.append(buffer_zone)
            
#             # convert the list of geoseries objects to a geodataframe
#             buffer_zones_df = gpd.GeoDataFrame(gpd.GeoSeries(buffer_zones[0]))
#             for k in range(1, len(buffer_zones)):
#                 buffer_zones_df.loc[k] = gpd.GeoSeries(buffer_zones[k])
#             buffer_zones_df = buffer_zones_df.rename(columns={0: 'geometry'}).set_geometry('geometry')
            
#             for m in range(buffer_zones_df.shape[0]):
#                 buffer_zone_dis_ch = buffer_zones_df.iloc[m:m+2].dissolve().convex_hull
#                 buffer_zones_list.append(buffer_zone_dis_ch)
#             buffer_zones_df_list.append(buffer_zones_df)
    
#     buffer_zones_list_df = gpd.GeoDataFrame(gpd.GeoSeries(buffer_zones_list[0]))
#     for m in range(1, len(buffer_zones_list)):
#         buffer_zones_list_df.loc[m] = gpd.GeoSeries(buffer_zones_list[m])
#     buffer_zones_list_df = buffer_zones_list_df.rename(columns={0: 'geometry'}).set_geometry('geometry')
#     buffer_zones_list_dis = buffer_zones_list_df.dissolve()

#     return buffer_zones_df_list, buffer_zones_list_dis

# genrate buffer zones surrounding polylines (segment by segment)_v5.0_similar to the previous version but considers aspect to generate buffer zones
def generate_buffer_zones(subduction_geoms, radius): # subduction_geoms generated by Utils.get_subduction_geometries()
    lines_list = []
    buffer_zones_list = []
    buffer_zones_df_list = []

    # add an appropriate vertex to the lines on anti-meridian
    for geom, aspect in subduction_geoms:
        index_list = []
        vertex_list = []
        xy = geom.to_lat_lon_array()
        num_xy = xy.shape[0]
        for i in range(num_xy-1):
            if xy[i, 1] * xy[i+1, 1] < 0 and 180 - abs(xy[i, 1]) < abs(xy[i, 1]):
                index_list.append(i+1)
                m = (xy[i+1, 0] - xy[i, 0]) / (xy[i+1, 1] - xy[i, 1])
                b = xy[i, 0] - (m * xy[i, 1])
                pos_vertex = [m*180+b, 180]
                neg_vertex = [m*-180+b, -180]
                if xy[i, 1] > 0:
                    vertex_list.append([pos_vertex, neg_vertex])
                else:
                    vertex_list.append([neg_vertex, pos_vertex])

        if len(index_list) > 0:
            xy = np.insert(xy, index_list, np.array(vertex_list[0]), 0)

        # split the line where it passes over anti-meridian
        index_list = []
        num_xy = xy.shape[0]
        for i in range(num_xy-1):
            if xy[i, 1] * xy[i+1, 1] < 0 and 180 - abs(xy[i, 1]) < abs(xy[i, 1]):
                index_list.append(i+1)
        xy_split = np.split(xy, index_list)
        xy_split.append(aspect)
        lines_list.append(xy_split)

    for line in lines_list:
        aspect = line[-1]
        for i in range(len(line)-1):
            buffer_zones = []
            for j in range(line[i].shape[0]-1):
                buffer_zone = gpd.GeoSeries(LineString([(line[i][j, 1], line[i][j, 0]), (line[i][j+1, 1], line[i][j+1, 0])]), crs='EPSG:4326').buffer(-1*aspect*radius, cap_style=2, single_sided=True)
                buffer_zones.append(buffer_zone)
            
            # convert the list of geoseries objects to a geodataframe
            buffer_zones_df = gpd.GeoDataFrame(gpd.GeoSeries(buffer_zones[0]))
            for k in range(1, len(buffer_zones)):
                buffer_zones_df.loc[k] = gpd.GeoSeries(buffer_zones[k])
            buffer_zones_df = buffer_zones_df.rename(columns={0: 'geometry'}).set_geometry('geometry')
            
            for m in range(buffer_zones_df.shape[0]):
                buffer_zone_dis_ch = buffer_zones_df.iloc[m:m+2].dissolve().convex_hull
                buffer_zones_list.append(buffer_zone_dis_ch)
            buffer_zones_df_list.append(buffer_zones_df)
    
    buffer_zones_list_df = gpd.GeoDataFrame(gpd.GeoSeries(buffer_zones_list[0]))
    for m in range(1, len(buffer_zones_list)):
        buffer_zones_list_df.loc[m] = gpd.GeoSeries(buffer_zones_list[m])
    buffer_zones_list_df = buffer_zones_list_df.rename(columns={0: 'geometry'}).set_geometry('geometry')
    buffer_zones_list_dis = buffer_zones_list_df.dissolve()

    return buffer_zones_df_list, buffer_zones_list_dis

# # genrate buffer zones surrounding polylines
# def generate_buffer_zones(subduction_geoms, radius): # subduction_geoms generated by Utils.get_subduction_geometries()
#     num_geoms = len(subduction_geoms)
#     buffer_zones = []
#     buffer_zones_dissolved = []
    
#     for i in range(num_geoms):
#         xy = subduction_geoms[i][0].to_lat_lon_list()
#         buffer_zone = gpd.GeoSeries(LineString(xy)).buffer(radius, cap_style=2)
#         buffer_zones.append(buffer_zone)
#     buffer_zones_df = gpd.GeoDataFrame(gpd.GeoSeries(buffer_zones[0]))
#     for k in range(1, len(buffer_zones)):
#         buffer_zones_df.loc[k] = gpd.GeoSeries(buffer_zones[k])
#     buffer_zones_df = buffer_zones_df.rename(columns={0: 'geometry'}).set_geometry('geometry')
#     # buffer_zone_dissolved = buffer_zones_df.dissolve()
#     # buffer_zones_dissolved.append(buffer_zone_dissolved)
      
#     return buffer_zones_df  
#     # return buffer_zones_dissolved

# # generate random samples inside a polygon
# def generate_random_samples(polygon_path, start_time, end_time, num_features):
#     polygon_obj = shapefile.Reader(polygon_path)
#     feature = polygon_obj.shapeRecords()[0]
#     first = feature.shape.__geo_interface__
#     polygon = shape(first)
    
#     times = np.random.randint(start_time, end_time+1, size=num_features*5).tolist()

#     bounds = polygon.bounds
    
#     rand_x = np.random.uniform(low=bounds[0], high=bounds[2], size=num_features*20)
#     rand_y = np.random.uniform(low=bounds[1], high=bounds[3], size=num_features*20)
#     non_deposit_x = []
#     non_deposit_y = []
    
#     for x, y in zip(rand_x, rand_y):
#         if len(non_deposit_x) == num_features*5:
#             print(f'{num_features*5} random samples generated successfully!')
#             break
#         p = Point((x, y))
#         if polygon.contains(p):
#             non_deposit_x.append(x)
#             non_deposit_y.append(y)
    
#     plate_ids = Utils.get_plate_id(non_deposit_x, non_deposit_y)

#     # index, lon, lat, time, plate id
#     data = []
    
#     for i in range(num_features*5):
#         data.append([i, non_deposit_x[i], non_deposit_y[i], times[i], plate_ids[i]])
#     data = np.array(data)
    
#     return data

# # generate random samples inside buffer zones_v1.0
# def generate_random_samples(buffer_zones, start_time, end_time, num_features, num_rand):
#     x_min = None
#     x_max = None
#     y_min = None
#     y_max = None
    
#     for buffer_zone in buffer_zones:
#         bounds = buffer_zone.bounds
#         if x_min == None:
#             x_min = bounds.loc[0]['minx']
#             x_max = bounds.loc[0]['maxx']
#             y_min = bounds.loc[0]['miny']
#             y_max = bounds.loc[0]['maxy']
#         else:
#             if bounds.loc[0]['minx'] < x_min:
#                 x_min = bounds.loc[0]['minx']
#             if bounds.loc[0]['maxx'] > x_max:
#                 x_max = bounds.loc[0]['maxx']
#             if bounds.loc[0]['miny'] < y_min:
#                 y_min = bounds.loc[0]['miny']
#             if bounds.loc[0]['maxy'] < y_max:
#                 y_max = bounds.loc[0]['maxy']

#     if x_min < -180:
#         x_min = -180
#     if x_max > 180:
#         x_max = 180
#     if y_min < -90:
#         y_min = -90
#     if y_max > 90:
#         y_max = 90

#     if start_time != end_time:
#         times = np.random.randint(start_time, end_time+1, size=num_features*5).tolist()
#     else:
#         times = [end_time]*num_features*5

#     rand_x_list = []
#     rand_y_list = []
    
#     for n in range(1, num_rand):
#         if len(rand_x_list) < num_features*5:
#             rand_x = np.random.uniform(low=x_min, high=x_max, size=num_features*n*5)
#             rand_y = np.random.uniform(low=y_min, high=y_max, size=num_features*n*5)
#             for x, y in zip(rand_x, rand_y):
#                 if len(rand_x_list) == num_features*5:
#                     break
#                 p = Point((x, y))
#                 for buffer_zone in buffer_zones:
#                     if p.within(buffer_zone.geometry[0]):
#                         rand_x_list.append(x)
#                         rand_y_list.append(y)
#                         break
#         else:
#             break
    
#     # print(f'{n} for {start_time}')
#     plate_ids = Utils.get_plate_id(rand_x_list, rand_y_list)

#     # index, lon, lat, time, plate id
#     data = []
    
#     for i in range(num_features*5):
#         data.append([i, rand_x_list[i], rand_y_list[i], times[i], plate_ids[i]])
#     data = np.array(data)
    
#     return data

# generate random samples inside buffer zones at a specific time step
def generate_random_samples(buffer_zone, time, num_samples, rand_factor):
# rand_factor: a factor which is multiplied by the number of samples (num_samples) and
# determines the total number of samples to be generated from which random samples are selected
    
    bounds = buffer_zone.bounds
    x_min = bounds.loc[0]['minx']
    x_max = bounds.loc[0]['maxx']
    y_min = bounds.loc[0]['miny']
    y_max = bounds.loc[0]['maxy']

    if x_min < -180:
        x_min = -180
    if x_max > 180:
        x_max = 180
    if y_min < -90:
        y_min = -90
    if y_max > 90:
        y_max = 90

    rand_x_list = []
    rand_y_list = []
    
    for n in range(1, rand_factor):
        if len(rand_x_list) < num_samples:
            rand_x = np.random.uniform(low=x_min, high=x_max, size=n*num_samples)
            rand_y = np.random.uniform(low=y_min, high=y_max, size=n*num_samples)
            for x, y in zip(rand_x, rand_y):
                if len(rand_x_list) == num_samples:
                    break
                p = Point((x, y))
                if p.within(buffer_zone.geometry[0]):
                    rand_x_list.append(x)
                    rand_y_list.append(y)
        else:
            break
    
    plate_ids = Utils.get_plate_id(rand_x_list, rand_y_list)
    # index, lon, lat, time, plate id
    data = []
    for i in range(num_samples):
        data.append([rand_x_list[i], rand_y_list[i], time, plate_ids[i]])
    data = np.array(data)
    
    return data

# # generate sampling points inside a polygon
# def generate_samples(polygon_path, dist_x, dist_y, start_time, end_time, map_extent):
#     polygon_obj = shapefile.Reader(polygon_path)
#     feature = polygon_obj.shapeRecords()[0]
#     first = feature.shape.__geo_interface__
#     polygon = shape(first)
    
#     x = np.arange(map_extent[0], map_extent[1], dist_x)
#     y = np.arange(map_extent[2], map_extent[3], dist_y)
#     nx = len(x)
#     ny = len(y)
#     xs, ys = np.meshgrid(x, y)

#     sample_x = []
#     sample_y = []
#     sample_mask = []
    
#     for xx, yy in zip(xs.flatten(), ys.flatten()):
#         p = Point((xx, yy))
#         if polygon.contains(p):
#             sample_x.append(xx)
#             sample_y.append(yy)
#             sample_mask.append(True)
#         else:
#             sample_mask.append(False)
    
#     mask_x = np.array([xs.flatten()]).T
#     mask_y = np.array([ys.flatten()]).T
#     sample_mask = np.array([sample_mask]).T
#     mask_coords = np.hstack((mask_x, mask_y, sample_mask))
    
#     plate_ids = Utils.get_plate_id(sample_x, sample_y)

#     # index, lon, lat, time, plate id
#     sample_data = []
#     k = 0
    
#     for i in range(start_time, end_time):
#         for j in range(len(sample_x)):
#             sample_data.append([k, sample_x[j], sample_y[j], i, plate_ids[j]])
#             k += 1
#     sample_data = np.array(sample_data)
    
#     return sample_data, mask_coords, nx, ny

# # generate sampling points inside buffer zones
# def generate_samples(buffer_zones, dist_x, dist_y, start_time, end_time):
#     x_min = None
#     x_max = None
#     y_min = None
#     y_max = None
    
#     for buffer_zone in buffer_zones:
#         bounds = buffer_zone.bounds
#         if x_min == None:
#             x_min = bounds.loc[0]['minx']
#             x_max = bounds.loc[0]['maxx']
#             y_min = bounds.loc[0]['miny']
#             y_max = bounds.loc[0]['maxy']
#         else:
#             if bounds.loc[0]['minx'] < x_min:
#                 x_min = bounds.loc[0]['minx']
#             if bounds.loc[0]['maxx'] > x_max:
#                 x_max = bounds.loc[0]['maxx']
#             if bounds.loc[0]['miny'] < y_min:
#                 y_min = bounds.loc[0]['miny']
#             if bounds.loc[0]['maxy'] < y_max:
#                 y_max = bounds.loc[0]['maxy']
    
#     if x_min < -180:
#         x_min = -180
#     if x_max > 180:
#         x_max = 180
#     if y_min < -90:
#         y_min = -90
#     if y_max > 90:
#         y_max = 90
    
#     x = np.arange(x_min, x_max, dist_x)
#     y = np.arange(y_min, y_max, dist_y)
#     nx = len(x)
#     ny = len(y)
#     xs, ys = np.meshgrid(x, y)

#     sample_x = []
#     sample_y = []
#     sample_mask = []
    
#     for xx, yy in zip(xs.flatten(), ys.flatten()):
#         p = Point((xx, yy))
#         for index, buffer_zone in enumerate(buffer_zones):
#             if p.within(buffer_zone.geometry[0]):
#                 sample_x.append(xx)
#                 sample_y.append(yy)
#                 sample_mask.append(True)
#                 break
#             if index == len(buffer_zones)-1:
#                 sample_mask.append(False)
    
#     mask_x = np.array([xs.flatten()]).T
#     mask_y = np.array([ys.flatten()]).T
#     sample_mask = np.array([sample_mask]).T
#     mask_coords = np.hstack((mask_x, mask_y, sample_mask))
    
#     plate_ids = Utils.get_plate_id(sample_x, sample_y)

#     # index, lon, lat, time, plate id
#     sample_data = []
#     k = 0
    
#     for i in range(start_time, end_time):
#         for j in range(len(sample_x)):
#             sample_data.append([k, sample_x[j], sample_y[j], i, plate_ids[j]])
#             k += 1
#     sample_data = np.array(sample_data)
    
#     return sample_data, mask_coords, nx, ny

# generate sampling points inside buffer zones at a specific time step
def generate_samples(buffer_zone, dist_x, dist_y, time):
    bounds = buffer_zone.bounds
    x_min = bounds.loc[0]['minx']
    x_max = bounds.loc[0]['maxx']
    y_min = bounds.loc[0]['miny']
    y_max = bounds.loc[0]['maxy']
    
    if x_min < -180:
        x_min = -180
    if x_max > 180:
        x_max = 180
    if y_min < -90:
        y_min = -90
    if y_max > 90:
        y_max = 90
    
    x = np.arange(x_min, x_max, dist_x)
    y = np.arange(y_min, y_max, dist_y)
    nx = len(x)
    ny = len(y)
    xs, ys = np.meshgrid(x, y)

    sample_x = []
    sample_y = []
    sample_mask = []
    
    for xx, yy in zip(xs.flatten(), ys.flatten()):
        p = Point((xx, yy))
        if p.within(buffer_zone.geometry[0]):
            sample_x.append(xx)
            sample_y.append(yy)
            sample_mask.append(True)
        else:
            sample_mask.append(False)
    
    mask_x = np.array([xs.flatten()]).T
    mask_y = np.array([ys.flatten()]).T
    sample_mask = np.array([sample_mask]).T
    mask_coords = np.hstack((mask_x, mask_y, sample_mask))
    
    plate_ids = Utils.get_plate_id(sample_x, sample_y)

    # index, lon, lat, time, plate id
    sample_data = []
    for i in range(len(sample_x)):
        sample_data.append([i, sample_x[i], sample_y[i], time, plate_ids[i]])
    sample_data = np.array(sample_data)
    
    return sample_data, mask_coords, nx, ny

def generate_trench_points(start_time, end_time, time_step):
    trench_data=[]
    trench_points = Utils.get_trench_points(0,-85,5,-70,-60) #subduction points in south america 
    i=0
    
    for t in range(start_time, end_time, time_step):
        for index, p in trench_points.iterrows():
            trench_data.append([i, p['trench_lon'], p['trench_lat'], t, p['trench_pid']]) 
            i+=1
            
    return trench_data    

def save_data(data,fn):
    # data are ready and write them to file
    with open(fn,'w+') as f:
        f.write('index,lon,lat,age,plate_id\n')
        for row in data:
            #print(row)
            if row:
                f.write('{0:d}, {1:.2f}, {2:.2f}, {3:d}, {4:d}'.format(
                    int(row[0]),float(row[1]),float(row[2]),int(row[3]),int(row[4])))
            f.write('\n')

    print(f'The data have been written into {fn} successfully!')                               

# if __name__ == '__main__':
#     start_time = parameters['time']['start']
#     end_time = parameters['time']['end']
#     time_step =  parameters['time']['step']
#     deposit_path = parameters['deposit_path']
#     polygon_path = parameters['region_of_interest_polygon']
#     # convergence_file = parameters['convergence_data_dir']+parameters['convergence_data_filename_prefix']+'_0.00.csv'
#     num_features = num_features = len(parameters['selected_features'])
#     map_extent = parameters['map_extent']
#     dist_x = 1
#     dist_y = 1

#     data = process_real_deposits(deposit_path, start_time, end_time, time_step)
#     random_data = generate_random_samples(polygon_path, start_time, end_time, num_features)
#     sample_data = generate_samples(polygon_path, dist_x, dist_y, start_time, end_time, map_extent)
#     trench_data = generate_trench_points(start_time, end_time, time_step)

#     all_data = data+random_data+trench_data
#     for i in range(len(all_data)):
#         all_data[i][0] = i # assign correct indices

#     save_data(all_data, 'coregistration_input_data_example.csv')
